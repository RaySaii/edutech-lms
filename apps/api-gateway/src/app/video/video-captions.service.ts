import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Video } from '@edutech-lms/database';
import * as fs from 'fs/promises';
import * as path from 'path';

interface CaptionTrack {
  id: string;
  language: string;
  label: string;
  isDefault: boolean;
  filePath: string;
  format: 'vtt' | 'srt' | 'ass';
  isAutoGenerated: boolean;
  createdAt: Date;
}

interface CaptionCue {
  start: number; // seconds
  end: number;   // seconds
  text: string;
  position?: {
    line?: number;
    vertical?: string;
    align?: string;
  };
}

export interface CreateCaptionDto {
  language: string;
  label: string;
  isDefault?: boolean;
  format: 'vtt' | 'srt' | 'ass';
  content?: string; // Raw caption content
  file?: Express.Multer.File;
}

export interface UpdateCaptionDto extends Partial<CreateCaptionDto> {}

@Injectable()
export class VideoCaptionsService {
  private readonly logger = new Logger(VideoCaptionsService.name);
  private readonly captionsPath = 'uploads/captions';

  constructor(
    @InjectRepository(Video)
    private videoRepository: Repository<Video>,
  ) {
    this.ensureDirectories();
  }

  private async ensureDirectories(): Promise<void> {
    try {
      await fs.mkdir(this.captionsPath, { recursive: true });
    } catch (error) {
      this.logger.error('Failed to create captions directory:', error);
    }
  }

  async createCaption(videoId: string, createDto: CreateCaptionDto): Promise<CaptionTrack> {
    const video = await this.videoRepository.findOne({ where: { id: videoId } });
    if (!video) {
      throw new NotFoundException(`Video ${videoId} not found`);
    }

    // Validate caption format
    this.validateCaptionFormat(createDto.format);

    // Process caption content
    let captionContent: string;
    if (createDto.file) {
      captionContent = createDto.file.buffer.toString('utf-8');
    } else if (createDto.content) {
      captionContent = createDto.content;
    } else {
      throw new BadRequestException('Either file or content must be provided');
    }

    // Validate caption content format
    await this.validateCaptionContent(captionContent, createDto.format);

    // Generate unique filename
    const captionId = this.generateCaptionId();
    const filename = `${videoId}-${captionId}-${createDto.language}.${createDto.format}`;
    const filePath = path.join(this.captionsPath, filename);

    // Save caption file
    await fs.writeFile(filePath, captionContent, 'utf-8');

    // Update video metadata
    const existingCaptions = video.subtitles || [];
    
    // If this is set as default, unset other defaults
    if (createDto.isDefault) {
      existingCaptions.forEach(caption => {
        caption.isDefault = false;
      });
    }

    const newCaption: CaptionTrack = {
      id: captionId,
      language: createDto.language,
      label: createDto.label,
      isDefault: createDto.isDefault || false,
      filePath,
      format: createDto.format,
      isAutoGenerated: false,
      createdAt: new Date(),
    };

    existingCaptions.push(newCaption);

    await this.videoRepository.update(videoId, {
      subtitles: existingCaptions,
    });

    this.logger.log(`Caption created for video ${videoId}: ${createDto.language}`);
    return newCaption;
  }

  async getCaptions(videoId: string): Promise<CaptionTrack[]> {
    const video = await this.videoRepository.findOne({
      where: { id: videoId },
      select: ['subtitles'],
    });

    if (!video) {
      throw new NotFoundException(`Video ${videoId} not found`);
    }

    return video.subtitles || [];
  }

  async getCaption(videoId: string, captionId: string): Promise<CaptionTrack> {
    const captions = await this.getCaptions(videoId);
    const caption = captions.find(c => c.id === captionId);
    
    if (!caption) {
      throw new NotFoundException(`Caption ${captionId} not found for video ${videoId}`);
    }

    return caption;
  }

  async getCaptionContent(videoId: string, captionId: string): Promise<string> {
    const caption = await this.getCaption(videoId, captionId);
    
    try {
      return await fs.readFile(caption.filePath, 'utf-8');
    } catch (error) {
      this.logger.error(`Failed to read caption file ${caption.filePath}:`, error);
      throw new NotFoundException('Caption file not found');
    }
  }

  async updateCaption(videoId: string, captionId: string, updateDto: UpdateCaptionDto): Promise<CaptionTrack> {
    const video = await this.videoRepository.findOne({ where: { id: videoId } });
    if (!video) {
      throw new NotFoundException(`Video ${videoId} not found`);
    }

    const captions = video.subtitles || [];
    const captionIndex = captions.findIndex(c => c.id === captionId);
    
    if (captionIndex === -1) {
      throw new NotFoundException(`Caption ${captionId} not found`);
    }

    const caption = captions[captionIndex];

    // Update caption metadata
    if (updateDto.language) caption.language = updateDto.language;
    if (updateDto.label) caption.label = updateDto.label;
    if (updateDto.isDefault !== undefined) {
      if (updateDto.isDefault) {
        // Unset other defaults
        captions.forEach((c, index) => {
          if (index !== captionIndex) c.isDefault = false;
        });
      }
      caption.isDefault = updateDto.isDefault;
    }

    // Update content if provided
    if (updateDto.content || updateDto.file) {
      let newContent: string;
      if (updateDto.file) {
        newContent = updateDto.file.buffer.toString('utf-8');
      } else {
        newContent = updateDto.content!;
      }

      const format = updateDto.format || caption.format;
      await this.validateCaptionContent(newContent, format);
      
      await fs.writeFile(caption.filePath, newContent, 'utf-8');
      
      if (updateDto.format && updateDto.format !== caption.format) {
        // Update filename if format changed
        const newFilename = caption.filePath.replace(
          `.${caption.format}`,
          `.${updateDto.format}`
        );
        await fs.rename(caption.filePath, newFilename);
        caption.filePath = newFilename;
        caption.format = updateDto.format;
      }
    }

    await this.videoRepository.update(videoId, { subtitles: captions });
    
    return caption;
  }

  async deleteCaption(videoId: string, captionId: string): Promise<void> {
    const video = await this.videoRepository.findOne({ where: { id: videoId } });
    if (!video) {
      throw new NotFoundException(`Video ${videoId} not found`);
    }

    const captions = video.subtitles || [];
    const captionIndex = captions.findIndex(c => c.id === captionId);
    
    if (captionIndex === -1) {
      throw new NotFoundException(`Caption ${captionId} not found`);
    }

    const caption = captions[captionIndex];

    // Delete file
    try {
      await fs.unlink(caption.filePath);
    } catch (error) {
      this.logger.warn(`Failed to delete caption file ${caption.filePath}:`, error);
    }

    // Remove from array
    captions.splice(captionIndex, 1);

    await this.videoRepository.update(videoId, { subtitles: captions });
    
    this.logger.log(`Caption deleted: ${captionId} from video ${videoId}`);
  }

  async generateAutoCaption(videoId: string, language = 'en'): Promise<CaptionTrack> {
    const video = await this.videoRepository.findOne({ where: { id: videoId } });
    if (!video) {
      throw new NotFoundException(`Video ${videoId} not found`);
    }

    // This is a placeholder for actual speech-to-text integration
    // In a real implementation, you would integrate with services like:
    // - Google Cloud Speech-to-Text
    // - Amazon Transcribe
    // - Azure Speech Services
    // - OpenAI Whisper
    
    const mockCaptions = await this.generateMockAutoCaption(video);
    
    const captionId = this.generateCaptionId();
    const filename = `${videoId}-${captionId}-${language}-auto.vtt`;
    const filePath = path.join(this.captionsPath, filename);

    await fs.writeFile(filePath, mockCaptions, 'utf-8');

    const existingCaptions = video.subtitles || [];
    const autoCaption: CaptionTrack = {
      id: captionId,
      language,
      label: `Auto-generated (${language.toUpperCase()})`,
      isDefault: existingCaptions.length === 0,
      filePath,
      format: 'vtt',
      isAutoGenerated: true,
      createdAt: new Date(),
    };

    existingCaptions.push(autoCaption);
    await this.videoRepository.update(videoId, { subtitles: existingCaptions });

    this.logger.log(`Auto-caption generated for video ${videoId}`);
    return autoCaption;
  }

  async parseCaptionContent(content: string, format: 'vtt' | 'srt' | 'ass'): Promise<CaptionCue[]> {
    switch (format) {
      case 'vtt':
        return this.parseVTT(content);
      case 'srt':
        return this.parseSRT(content);
      case 'ass':
        return this.parseASS(content);
      default:
        throw new BadRequestException(`Unsupported caption format: ${format}`);
    }
  }

  async convertCaptionFormat(
    content: string, 
    fromFormat: 'vtt' | 'srt' | 'ass', 
    toFormat: 'vtt' | 'srt' | 'ass'
  ): Promise<string> {
    if (fromFormat === toFormat) return content;

    const cues = await this.parseCaptionContent(content, fromFormat);
    return this.formatCaptions(cues, toFormat);
  }

  private validateCaptionFormat(format: string): void {
    const supportedFormats = ['vtt', 'srt', 'ass'];
    if (!supportedFormats.includes(format)) {
      throw new BadRequestException(`Unsupported caption format: ${format}`);
    }
  }

  private async validateCaptionContent(content: string, format: 'vtt' | 'srt' | 'ass'): Promise<void> {
    try {
      await this.parseCaptionContent(content, format);
    } catch (error) {
      throw new BadRequestException(`Invalid ${format.toUpperCase()} format: ${error.message}`);
    }
  }

  private parseVTT(content: string): CaptionCue[] {
    const lines = content.split('\n');
    const cues: CaptionCue[] = [];
    let i = 0;

    // Skip WEBVTT header
    while (i < lines.length && !lines[i].includes('-->')) {
      i++;
    }

    while (i < lines.length) {
      const line = lines[i].trim();
      
      if (line.includes('-->')) {
        const timeParts = line.split('-->');
        const startTime = this.parseTimeVTT(timeParts[0].trim());
        const endTime = this.parseTimeVTT(timeParts[1].trim());
        
        i++;
        let text = '';
        while (i < lines.length && lines[i].trim() !== '') {
          text += (text ? '\n' : '') + lines[i].trim();
          i++;
        }

        cues.push({
          start: startTime,
          end: endTime,
          text: text,
        });
      }
      i++;
    }

    return cues;
  }

  private parseSRT(content: string): CaptionCue[] {
    const blocks = content.split('\n\n').filter(block => block.trim());
    const cues: CaptionCue[] = [];

    for (const block of blocks) {
      const lines = block.split('\n');
      if (lines.length < 3) continue;

      const timeLine = lines[1];
      if (!timeLine.includes('-->')) continue;

      const timeParts = timeLine.split('-->');
      const startTime = this.parseTimeSRT(timeParts[0].trim());
      const endTime = this.parseTimeSRT(timeParts[1].trim());

      const text = lines.slice(2).join('\n');

      cues.push({
        start: startTime,
        end: endTime,
        text: text,
      });
    }

    return cues;
  }

  private parseASS(content: string): CaptionCue[] {
    // Simplified ASS parser - in production, you'd want a more robust parser
    const lines = content.split('\n');
    const cues: CaptionCue[] = [];

    for (const line of lines) {
      if (line.startsWith('Dialogue:')) {
        const parts = line.split(',');
        if (parts.length < 10) continue;

        const startTime = this.parseTimeASS(parts[1]);
        const endTime = this.parseTimeASS(parts[2]);
        const text = parts.slice(9).join(',').replace(/\\N/g, '\n');

        cues.push({
          start: startTime,
          end: endTime,
          text: text,
        });
      }
    }

    return cues;
  }

  private formatCaptions(cues: CaptionCue[], format: 'vtt' | 'srt' | 'ass'): string {
    switch (format) {
      case 'vtt':
        return this.formatVTT(cues);
      case 'srt':
        return this.formatSRT(cues);
      case 'ass':
        return this.formatASS(cues);
    }
  }

  private formatVTT(cues: CaptionCue[]): string {
    let output = 'WEBVTT\n\n';
    
    cues.forEach((cue, index) => {
      output += `${index + 1}\n`;
      output += `${this.formatTimeVTT(cue.start)} --> ${this.formatTimeVTT(cue.end)}\n`;
      output += `${cue.text}\n\n`;
    });

    return output;
  }

  private formatSRT(cues: CaptionCue[]): string {
    let output = '';
    
    cues.forEach((cue, index) => {
      output += `${index + 1}\n`;
      output += `${this.formatTimeSRT(cue.start)} --> ${this.formatTimeSRT(cue.end)}\n`;
      output += `${cue.text}\n\n`;
    });

    return output;
  }

  private formatASS(cues: CaptionCue[]): string {
    let output = '[Script Info]\nTitle: Auto-generated\nScriptType: v4.00+\n\n';
    output += '[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n';
    output += 'Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1\n\n';
    output += '[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n';
    
    cues.forEach(cue => {
      output += `Dialogue: 0,${this.formatTimeASS(cue.start)},${this.formatTimeASS(cue.end)},Default,,0,0,0,,${cue.text.replace(/\n/g, '\\N')}\n`;
    });

    return output;
  }

  private parseTimeVTT(timeStr: string): number {
    const parts = timeStr.split(':');
    const seconds = parseFloat(parts[parts.length - 1]);
    const minutes = parseInt(parts[parts.length - 2] || '0');
    const hours = parseInt(parts[parts.length - 3] || '0');
    
    return hours * 3600 + minutes * 60 + seconds;
  }

  private parseTimeSRT(timeStr: string): number {
    const [time, ms] = timeStr.split(',');
    const [hours, minutes, seconds] = time.split(':').map(Number);
    
    return hours * 3600 + minutes * 60 + seconds + (parseInt(ms) / 1000);
  }

  private parseTimeASS(timeStr: string): number {
    const [hours, minutes, seconds] = timeStr.split(':');
    const [sec, centiseconds] = seconds.split('.');
    
    return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(sec) + (parseInt(centiseconds || '0') / 100);
  }

  private formatTimeVTT(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = (seconds % 60).toFixed(3);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;
  }

  private formatTimeSRT(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const sec = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
  }

  private formatTimeASS(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const sec = Math.floor(seconds % 60);
    const centiseconds = Math.floor((seconds % 1) * 100);
    
    return `${hours}:${minutes.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
  }

  private generateCaptionId(): string {
    return `caption_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  private async generateMockAutoCaption(video: Video): Promise<string> {
    // This is a mock implementation - replace with actual speech-to-text
    const duration = video.duration || 60;
    const segments = Math.floor(duration / 5); // 5-second segments
    
    let vtt = 'WEBVTT\n\n';
    
    for (let i = 0; i < segments; i++) {
      const start = i * 5;
      const end = Math.min(start + 5, duration);
      
      vtt += `${i + 1}\n`;
      vtt += `${this.formatTimeVTT(start)} --> ${this.formatTimeVTT(end)}\n`;
      vtt += `Auto-generated caption segment ${i + 1}\n\n`;
    }
    
    return vtt;
  }
}